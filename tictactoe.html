<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>C·ªù Caro ƒêa NƒÉng - AI & PvP</title>
<script src="https://cdn.tailwindcss.com"></script>
<link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;700;900&display=swap" rel="stylesheet">
<style>
    body {
        font-family: 'Nunito', sans-serif;
        background-color: #f8fafc; /* Slate-50 */
        touch-action: manipulation;
        overscroll-behavior: none;
    }
    
    /* Hi·ªáu ·ª©ng X/O xu·∫•t hi·ªán */
    @keyframes popIn {
        0% { transform: scale(0.5); opacity: 0; }
        70% { transform: scale(1.2); }
        100% { transform: scale(1); opacity: 1; }
    }
    
    .cell-content {
        animation: popIn 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
    }

    /* Container cho b√†n c·ªù c√≥ th·ªÉ cu·ªôn */
    .board-scroll-container {
        overflow: auto;
        max-width: 100%;
        max-height: 75vh; /* Gi·ªõi h·∫°n chi·ªÅu cao ƒë·ªÉ kh√¥ng ƒë·∫©y UI kh√°c */
        display: flex;
        justify-content: center; /* CƒÉn gi·ªØa n·∫øu b√†n c·ªù nh·ªè */
        align-items: flex-start;
        padding: 4px;
        border-radius: 8px;
        /* T√πy ch·ªânh thanh cu·ªôn cho ƒë·∫πp */
        scrollbar-width: thin;
        scrollbar-color: #cbd5e1 #f1f5f9;
    }
    
    .board-scroll-container::-webkit-scrollbar {
        width: 8px;
        height: 8px;
    }
    .board-scroll-container::-webkit-scrollbar-track {
        background: #f1f5f9; 
    }
    .board-scroll-container::-webkit-scrollbar-thumb {
        background-color: #cbd5e1; 
        border-radius: 4px;
    }

    /* L∆∞·ªõi game */
    .game-grid {
        display: grid;
        gap: 1px; /* ƒê∆∞·ªùng k·∫ª gi·ªØa c√°c √¥ */
        background-color: #94a3b8; /* M√†u ƒë∆∞·ªùng k·∫ª */
        border: 1px solid #94a3b8;
        border-radius: 4px;
        box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        flex-shrink: 0; /* Kh√¥ng b·ªã co l·∫°i trong flex container */
    }

    /* √î c·ªù */
    .cell {
        background-color: white;
        display: flex;
        justify-content: center;
        align-items: center;
        font-weight: 900;
        cursor: pointer;
        user-select: none;
        position: relative;
        /* ƒê·∫£m b·∫£o √¥ vu√¥ng */
        aspect-ratio: 1/1; 
    }

    /* Lo·∫°i b·ªè hover tr√™n mobile ƒë·ªÉ tr√°nh d√≠nh m√†u */
    @media (hover: hover) {
        .cell:hover:not(.filled) {
            background-color: #f1f5f9;
        }
    }

    .cell.filled {
        cursor: default;
        background-color: #fff;
    }

    /* Highlight th·∫Øng/thua/n∆∞·ªõc ƒëi cu·ªëi */
    .cell.highlight {
        background-color: #bbf7d0 !important; /* Green-200 */
    }
    .cell.highlight .text-x { color: #14532d !important; }
    .cell.highlight .text-o { color: #064e3b !important; }

    .cell.last-move {
        background-color: #fef9c3; /* Yellow-100 */
    }
    /* D·∫•u hi·ªáu n∆∞·ªõc ƒëi cu·ªëi (ch·∫•m nh·ªè) */
    .cell.last-move::after {
        content: '';
        position: absolute;
        top: 4px;
        right: 4px;
        width: 6px;
        height: 6px;
        background-color: #eab308; /* Yellow-500 */
        border-radius: 50%;
    }

    /* M√†u ch·ªØ */
    .text-x { 
        color: #ef4444; /* Red-500 */
        filter: drop-shadow(1px 1px 0px rgba(239, 68, 68, 0.2));
    } 
    .text-o { 
        color: #3b82f6; /* Blue-500 */
        filter: drop-shadow(1px 1px 0px rgba(59, 130, 246, 0.2));
    }

    /* Modal */
    .btn-option.selected {
        background-color: #1e293b; /* Slate-800 */
        color: white;
        border-color: #1e293b;
        box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
    }
    .modal-overlay {
        background-color: rgba(15, 23, 42, 0.8);
        backdrop-filter: blur(4px);
    }
</style>
</head>
<body class="h-screen flex flex-col text-slate-800 overflow-hidden">

    <!-- Header -->
    <header class="pt-4 pb-2 px-4 flex-none z-10 bg-f8fafc shadow-sm">
        <div class="max-w-md mx-auto text-center">
            <h1 class="text-2xl font-bold text-slate-700 leading-tight">C·ªù Caro</h1>
            <div class="flex justify-between items-center mt-2 text-xs font-semibold text-slate-500 px-2">
                <span id="mode-display">PvE</span>
                <span id="size-display">10x10</span>
            </div>
            
            <!-- Score Board -->
            <div class="mt-2 flex items-center justify-center gap-6 bg-white px-6 py-2 rounded-full shadow border border-slate-200 mx-auto w-fit">
                <div class="flex flex-col items-center w-12">
                    <span id="p1-label" class="text-xs font-bold text-slate-400 uppercase">B·∫°n</span>
                    <span id="p1-badge" class="text-2xl font-black text-x leading-none">X</span>
                </div>
                <div class="text-slate-300 text-2xl font-light">vs</div>
                <div class="flex flex-col items-center w-12">
                    <span id="p2-label" class="text-xs font-bold text-slate-400 uppercase">M√°y</span>
                    <span id="p2-badge" class="text-2xl font-black text-o leading-none">O</span>
                </div>
            </div>
            
            <div id="status-msg" class="mt-2 h-6 text-sm font-bold text-blue-600 flex items-center justify-center">
                <!-- Status text here -->
            </div>
        </div>
    </header>

    <!-- Main Game Area -->
    <main class="flex-1 relative w-full flex flex-col items-center justify-center overflow-hidden bg-slate-50">
        <!-- Board Container -->
        <div class="board-scroll-container w-full px-2" id="board-wrapper">
            <div id="board" class="game-grid mx-auto">
                <!-- Cells generated by JS -->
            </div>
        </div>
    </main>

    <!-- Footer -->
    <footer class="p-4 flex-none bg-white border-t border-slate-200 z-10">
        <div class="max-w-md mx-auto flex gap-3">
            <button onclick="showIntro()" class="flex-1 py-3 bg-slate-100 text-slate-600 font-bold rounded-xl hover:bg-slate-200 active:scale-95 transition">
                C√†i ƒë·∫∑t
            </button>
            <button onclick="resetBoard()" class="flex-1 py-3 bg-slate-800 text-white font-bold rounded-xl hover:bg-slate-700 active:scale-95 transition shadow-lg shadow-slate-300">
                Ch∆°i l·∫°i
            </button>
        </div>
    </footer>

    <!-- Intro / Settings Modal -->
    <div id="intro-modal" class="fixed inset-0 z-50 flex items-center justify-center modal-overlay p-4">
        <div class="bg-white w-full max-w-sm rounded-3xl shadow-2xl overflow-hidden transform transition-all scale-100 max-h-[90vh] flex flex-col">
            <div class="bg-slate-800 p-6 text-center">
                <h2 class="text-2xl font-black text-white tracking-wide">THI·∫æT L·∫¨P</h2>
                <p class="text-slate-400 text-sm mt-1">T√πy ch·ªânh tr·∫≠n ƒë·∫•u c·ªßa b·∫°n</p>
            </div>
            
            <div class="p-6 overflow-y-auto">
                <!-- K√≠ch th∆∞·ªõc -->
                <div class="mb-6">
                    <label class="block text-xs font-bold text-slate-500 uppercase tracking-wider mb-3">K√≠ch th∆∞·ªõc b√†n c·ªù</label>
                    <div class="grid grid-cols-4 gap-2">
                        <button onclick="selectSize(3)" class="btn-option size-opt py-2 rounded-lg border-2 border-slate-100 font-bold text-slate-600 text-sm hover:border-slate-300" data-val="3">3x3</button>
                        <button onclick="selectSize(5)" class="btn-option size-opt py-2 rounded-lg border-2 border-slate-100 font-bold text-slate-600 text-sm hover:border-slate-300" data-val="5">5x5</button>
                        <button onclick="selectSize(10)" class="btn-option size-opt py-2 rounded-lg border-2 border-slate-100 font-bold text-slate-600 text-sm hover:border-slate-300 selected" data-val="10">10x10</button>
                        <button onclick="selectSize(20)" class="btn-option size-opt py-2 rounded-lg border-2 border-slate-100 font-bold text-slate-600 text-sm hover:border-slate-300" data-val="20">20x20</button>
                    </div>
                    <p id="rule-hint" class="text-xs text-slate-400 mt-2 text-center italic">Lu·∫≠t th·∫Øng: 4 √¥ li√™n ti·∫øp</p>
                </div>

                <!-- Ch·∫ø ƒë·ªô -->
                <div class="mb-6">
                    <label class="block text-xs font-bold text-slate-500 uppercase tracking-wider mb-3">Ch·∫ø ƒë·ªô ch∆°i</label>
                    <div class="grid grid-cols-2 gap-3">
                        <button onclick="selectMode('pve')" class="btn-option mode-opt py-3 rounded-xl border-2 border-slate-100 font-bold text-slate-700 hover:border-slate-300 flex items-center justify-center gap-2 selected" data-val="pve">
                            <span>ü§ñ</span> Vs M√°y
                        </button>
                        <button onclick="selectMode('pvp')" class="btn-option mode-opt py-3 rounded-xl border-2 border-slate-100 font-bold text-slate-700 hover:border-slate-300 flex items-center justify-center gap-2" data-val="pvp">
                            <span>üë•</span> 2 Ng∆∞·ªùi
                        </button>
                    </div>
                </div>

                <!-- Phe -->
                <div class="mb-6">
                    <label class="block text-xs font-bold text-slate-500 uppercase tracking-wider mb-3">Ch·ªçn qu√¢n (X ƒëi tr∆∞·ªõc)</label>
                    <div class="grid grid-cols-2 gap-3">
                        <button onclick="selectSide('X')" class="btn-option side-opt py-3 rounded-xl border-2 border-slate-100 font-black text-xl text-red-500 hover:border-red-200 selected" data-val="X">X</button>
                        <button onclick="selectSide('O')" class="btn-option side-opt py-3 rounded-xl border-2 border-slate-100 font-black text-xl text-blue-500 hover:border-blue-200" data-val="O">O</button>
                    </div>
                </div>

                <button onclick="startGame()" class="w-full py-4 bg-slate-800 text-white font-bold rounded-xl hover:bg-slate-900 active:scale-95 transition shadow-xl shadow-slate-300 text-lg">
                    V√ÄO TR·∫¨N
                </button>
            </div>
        </div>
    </div>

    <!-- Result Modal -->
    <div id="result-modal" class="fixed inset-0 z-50 flex items-center justify-center modal-overlay hidden p-4">
        <div class="bg-white w-full max-w-xs p-6 rounded-3xl shadow-2xl text-center transform scale-100 transition-all">
            <div id="result-icon" class="text-6xl mb-2 animate-bounce">üèÜ</div>
            <h2 id="result-title" class="text-2xl font-black text-slate-800 mb-1">CHI·∫æN TH·∫ÆNG!</h2>
            <p id="result-message" class="text-slate-500 mb-6 font-medium text-sm">Ch√∫c m·ª´ng b·∫°n ƒë√£ th·∫Øng.</p>
            
            <div class="flex flex-col gap-2">
                <button onclick="resetBoard()" class="w-full py-3 bg-slate-800 text-white font-bold rounded-xl hover:bg-slate-700 shadow-lg">
                    Ch∆°i v√°n m·ªõi
                </button>
                <button onclick="showIntro()" class="w-full py-3 text-slate-500 font-bold hover:text-slate-700">
                    ƒê·ªïi c√†i ƒë·∫∑t
                </button>
            </div>
        </div>
    </div>

<script>
    /* ================= STATE VARIABLES ================= */
    let SETTINGS = {
        size: 10,
        mode: 'pve', // 'pve' | 'pvp'
        playerSide: 'X',
        winLength: 4
    };

    let gameState = {
        board: [],
        gameActive: false,
        currentPlayer: 'X',
        moveCount: 0
    };

    const boardElement = document.getElementById('board');
    const statusMsg = document.getElementById('status-msg');

    /* ================= UI HANDLING (INTRO) ================= */
    
    function selectSize(size) {
        SETTINGS.size = size;
        SETTINGS.winLength = size === 3 ? 3 : (size === 5 ? 4 : (size >= 20 ? 5 : 4));
        // 20x20 th∆∞·ªùng lu·∫≠t l√† 5 √¥, nh∆∞ng user y√™u c·∫ßu 4 th√¨ gi·ªØ 4 c≈©ng ƒë∆∞·ª£c. 
        // ƒê·ªÉ c√¢n b·∫±ng cho 20x20 ta c√≥ th·ªÉ set l√† 5 √¥ th·∫Øng (chu·∫©n gomoku) ho·∫∑c gi·ªØ 4 theo y√™u c·∫ßu.
        // ·ªû ƒë√¢y gi·ªØ 4 theo prompt, nh∆∞ng 20x20 4 √¥ th√¨ h∆°i d·ªÖ h√≤a/th·∫Øng nhanh. 
        // Code d∆∞·ªõi s·∫Ω follow prompt l√† 4 √¥ th·∫≥ng h√†ng.
        SETTINGS.winLength = size === 3 ? 3 : 4; 

        document.getElementById('rule-hint').textContent = `Lu·∫≠t th·∫Øng: ${SETTINGS.winLength} √¥ li√™n ti·∫øp`;
        updateBtnStyles('size-opt', size);
    }

    function selectMode(mode) {
        SETTINGS.mode = mode;
        updateBtnStyles('mode-opt', mode);
    }

    function selectSide(side) {
        SETTINGS.playerSide = side;
        updateBtnStyles('side-opt', side);
    }

    function updateBtnStyles(className, value) {
        document.querySelectorAll(`.${className}`).forEach(btn => {
            if (btn.dataset.val == value) btn.classList.add('selected', 'border-transparent');
            else btn.classList.remove('selected', 'border-transparent');
        });
    }

    function showIntro() {
        document.getElementById('intro-modal').classList.remove('hidden');
        document.getElementById('result-modal').classList.add('hidden');
    }

    /* ================= GAME INITIALIZATION ================= */

    function startGame() {
        document.getElementById('intro-modal').classList.add('hidden');
        
        // Update Info Display
        const modeText = SETTINGS.mode === 'pve' ? 'Ng∆∞·ªùi vs M√°y' : 'ƒê·ªëi kh√°ng';
        document.getElementById('mode-display').textContent = modeText;
        document.getElementById('size-display').textContent = `${SETTINGS.size}x${SETTINGS.size}`;

        // Update Header Labels
        const p1Label = document.getElementById('p1-label');
        const p2Label = document.getElementById('p2-label');
        const p1Badge = document.getElementById('p1-badge');
        const p2Badge = document.getElementById('p2-badge');

        if (SETTINGS.mode === 'pve') {
            p1Label.textContent = 'B·∫†N';
            p1Badge.textContent = SETTINGS.playerSide;
            p1Badge.className = `text-2xl font-black leading-none ${SETTINGS.playerSide==='X'?'text-x':'text-o'}`;
            
            p2Label.textContent = 'M√ÅY';
            const aiSide = SETTINGS.playerSide === 'X' ? 'O' : 'X';
            p2Badge.textContent = aiSide;
            p2Badge.className = `text-2xl font-black leading-none ${aiSide==='X'?'text-x':'text-o'}`;
        } else {
            p1Label.textContent = 'P1';
            p1Badge.textContent = 'X';
            p1Badge.className = 'text-2xl font-black leading-none text-x';
            
            p2Label.textContent = 'P2';
            p2Badge.textContent = 'O';
            p2Badge.className = 'text-2xl font-black leading-none text-o';
        }

        resetBoard();
    }

    function resetBoard() {
        document.getElementById('result-modal').classList.add('hidden');
        gameState.board = new Array(SETTINGS.size * SETTINGS.size).fill('');
        gameState.gameActive = true;
        gameState.currentPlayer = 'X';
        gameState.moveCount = 0;

        // 1. C·∫•u h√¨nh Grid CSS
        boardElement.style.gridTemplateColumns = `repeat(${SETTINGS.size}, 1fr)`;
        
        // 2. T√≠nh to√°n k√≠ch th∆∞·ªõc √¥ (Cell Size Logic)
        // ƒê·ªÉ ƒë·∫£m b·∫£o √¥ lu√¥n ƒë·ªß l·ªõn ƒë·ªÉ b·∫•m tr√™n 20x20 v√† ƒë·∫πp tr√™n 3x3
        let minCellSize = 35; // K√≠ch th∆∞·ªõc t·ªëi thi·ªÉu cho mobile (px)
        let fontSize = '1.2rem';

        if (SETTINGS.size === 3) { minCellSize = 100; fontSize = '4rem'; }
        else if (SETTINGS.size === 5) { minCellSize = 60; fontSize = '2.5rem'; }
        else if (SETTINGS.size === 10) { minCellSize = 40; fontSize = '1.5rem'; }
        else if (SETTINGS.size === 20) { minCellSize = 32; fontSize = '1rem'; }

        // √Åp d·ª•ng min-width cho board ƒë·ªÉ k√≠ch ho·∫°t scroll n·∫øu c·∫ßn
        const boardWidth = minCellSize * SETTINGS.size;
        boardElement.style.minWidth = `${boardWidth}px`;
        boardElement.style.maxWidth = SETTINGS.size <= 10 ? '500px' : 'none'; // 3x3, 5x5, 10x10 gi·ªõi h·∫°n width cho ƒë·∫πp, 20x20 th·∫£ l·ªèng
        if (SETTINGS.size === 20) boardElement.style.width = `${boardWidth}px`; // Fix width cho b√†n l·ªõn
        
        // Reset Scroll
        document.getElementById('board-wrapper').scrollLeft = 0;
        document.getElementById('board-wrapper').scrollTop = 0;

        // 3. Render Cells
        boardElement.innerHTML = '';
        for (let i = 0; i < SETTINGS.size * SETTINGS.size; i++) {
            const cell = document.createElement('div');
            cell.className = 'cell';
            cell.style.fontSize = fontSize;
            cell.dataset.index = i;
            // Th√™m th·∫ª span b√™n trong ƒë·ªÉ animate n·ªôi dung
            const content = document.createElement('span');
            content.className = 'cell-content';
            cell.appendChild(content);
            
            cell.addEventListener('click', handleCellClick);
            boardElement.appendChild(cell);
        }

        updateStatus();

        // AI ƒëi tr∆∞·ªõc n·∫øu c·∫ßn
        if (SETTINGS.mode === 'pve' && SETTINGS.playerSide === 'O') {
            statusMsg.textContent = "M√°y ƒëang t√≠nh...";
            setTimeout(() => {
                // ƒê√°nh gi·ªØa
                const center = Math.floor((SETTINGS.size * SETTINGS.size) / 2);
                // ƒêi·ªÅu ch·ªânh m·ªôt ch√∫t cho b√†n ch·∫µn ƒë·ªÉ AI kh√¥ng ƒë√°nh qu√° c·ª©ng nh·∫Øc
                const offset = SETTINGS.size % 2 === 0 ? -(SETTINGS.size / 2) : 0;
                makeMove(center + offset, 'X'); 
            }, 600);
        }
    }

    /* ================= GAMEPLAY LOGIC ================= */

    function updateStatus() {
        if (!gameState.gameActive) return;
        
        const cur = gameState.currentPlayer;
        let msg = `L∆∞·ª£t c·ªßa ${cur}`;
        
        if (SETTINGS.mode === 'pve') {
            if (cur === SETTINGS.playerSide) {
                msg = "L∆∞·ª£t c·ªßa B·∫†N";
                statusMsg.classList.remove('text-slate-500');
                statusMsg.classList.add(SETTINGS.playerSide === 'X' ? 'text-red-500' : 'text-blue-500');
            } else {
                msg = "M√°y ƒëang t√≠nh...";
                statusMsg.className = "mt-2 h-6 text-sm font-bold text-slate-500 flex items-center justify-center animate-pulse";
            }
        } else {
            msg = `L∆∞·ª£t ng∆∞·ªùi ch∆°i ${cur}`;
            statusMsg.className = `mt-2 h-6 text-sm font-bold flex items-center justify-center ${cur==='X' ? 'text-red-500' : 'text-blue-500'}`;
        }
        
        statusMsg.textContent = msg;
    }

    function handleCellClick(e) {
        // X·ª≠ l√Ω click tr√∫ng span con ho·∫∑c div cha
        const target = e.target.closest('.cell');
        if (!target) return;
        
        const index = parseInt(target.dataset.index);

        if (gameState.board[index] !== '' || !gameState.gameActive) return;
        if (SETTINGS.mode === 'pve' && gameState.currentPlayer !== SETTINGS.playerSide) return;

        makeMove(index, gameState.currentPlayer);
    }

    function makeMove(index, player) {
        gameState.board[index] = player;
        gameState.moveCount++;

        // Update UI
        const cell = document.querySelector(`.cell[data-index='${index}']`);
        const content = cell.querySelector('.cell-content'); // L·∫•y span con
        
        content.textContent = player;
        content.classList.add(player === 'X' ? 'text-x' : 'text-o');
        cell.classList.add('filled');
        
        // Highlight last move
        document.querySelectorAll('.last-move').forEach(c => c.classList.remove('last-move'));
        cell.classList.add('last-move');

        // Check Win
        const winInfo = checkWin(gameState.board, player);
        if (winInfo) {
            endGame(player, winInfo);
            return;
        }

        // Check Draw
        if (gameState.moveCount === SETTINGS.size * SETTINGS.size) {
            endGame('draw', null);
            return;
        }

        // Switch Turn
        gameState.currentPlayer = player === 'X' ? 'O' : 'X';
        updateStatus();

        // Trigger AI
        if (SETTINGS.mode === 'pve' && gameState.currentPlayer !== SETTINGS.playerSide) {
            setTimeout(() => {
                const bestMove = getBestMove();
                makeMove(bestMove, gameState.currentPlayer);
            }, 250); // Delay nh·ªè t·∫°o c·∫£m gi√°c t·ª± nhi√™n
        }
    }

    function endGame(winner, winInfo) {
        gameState.gameActive = false;
        const modal = document.getElementById('result-modal');
        const title = document.getElementById('result-title');
        const msg = document.getElementById('result-message');
        const icon = document.getElementById('result-icon');

        if (winner === 'draw') {
            title.textContent = "H√íA C·ªú!";
            title.className = "text-2xl font-black text-slate-500 mb-1";
            msg.textContent = "Hai b√™n ngang t√†i ngang s·ª©c.";
            icon.textContent = "ü§ù";
        } else {
            // Highlight Winning Line
            winInfo.line.forEach(idx => {
                const cell = document.querySelector(`.cell[data-index='${idx}']`);
                if(cell) cell.classList.add('highlight');
            });

            if (SETTINGS.mode === 'pve') {
                if (winner === SETTINGS.playerSide) {
                    title.textContent = "CHI·∫æN TH·∫ÆNG!";
                    title.className = "text-2xl font-black text-green-600 mb-1";
                    msg.textContent = "B·∫°n ƒë√£ ƒë√°nh b·∫°i AI xu·∫•t s·∫Øc!";
                    icon.textContent = "üéâ";
                } else {
                    title.textContent = "TH·∫§T B·∫†I!";
                    title.className = "text-2xl font-black text-red-500 mb-1";
                    msg.textContent = "M√°y ch∆°i hay qu√°, th·ª≠ l·∫°i nh√©!";
                    icon.textContent = "ü§ñ";
                }
            } else {
                title.textContent = `${winner} TH·∫ÆNG!`;
                title.className = `text-2xl font-black ${winner==='X'?'text-red-500':'text-blue-500'} mb-1`;
                msg.textContent = `Ch√∫c m·ª´ng ng∆∞·ªùi ch∆°i ${winner}.`;
                icon.textContent = "üèÜ";
            }
        }

        setTimeout(() => {
            modal.classList.remove('hidden');
        }, 800);
    }

    /* ================= AI LOGIC (SCALABLE MINIMAX) ================= */

    function getBestMove() {
        // N·∫øu board qu√° tr·ªëng ·ªü l∆∞·ª£t ƒë·∫ßu, AI ƒë√°nh random quanh gi·ªØa
        if (gameState.moveCount < 2) {
            let center = Math.floor((SETTINGS.size * SETTINGS.size) / 2);
            // T√¨m √¥ tr·ªëng g·∫ßn nh·∫•t
            if (gameState.board[center] === '') return center;
            // N·∫øu gi·ªØa b·ªã chi·∫øm, ƒë√°nh xung quanh
            let neighbors = [-1, 1, -SETTINGS.size, SETTINGS.size];
            for (let offset of neighbors) {
                if (gameState.board[center + offset] === '') return center + offset;
            }
        }

        const aiPlayer = gameState.currentPlayer;
        // Gi·∫£m ƒë·ªô s√¢u cho b√†n c·ªù l·ªõn ƒë·ªÉ tr√°nh lag
        // 3x3: Full | 5x5: Depth 6 | 10x10: Depth 3 | 20x20: Depth 2
        const depth = SETTINGS.size <= 3 ? 9 : (SETTINGS.size <= 5 ? 5 : (SETTINGS.size >= 20 ? 2 : 3));
        
        let bestScore = -Infinity;
        let move = -1;
        
        // Ch·ªâ x√©t c√°c √¥ xung quanh c√°c √¥ ƒë√£ ƒë√°nh (Optimization)
        let candidates = getCandidateMoves(gameState.board);
        
        // N·∫øu qu√° nhi·ªÅu candidates (vd b√†n 20x20 gi·ªØa game), c·∫Øt b·ªõt ƒë·ªÉ ƒë·∫£m b·∫£o hi·ªáu nƒÉng
        if (candidates.length > 25) {
            // Shuffle v√† l·∫•y 25 √¥ ng·∫´u nhi√™n trong s·ªë c√°c √¥ kh·∫£ thi (heuristic ƒë∆°n gi·∫£n)
            // Th·ª±c t·∫ø n√™n d√πng h√†m ƒë√°nh gi√° s∆° b·ªô ƒë·ªÉ sort, nh∆∞ng ·ªü ƒë√¢y shuffle l√† ƒë·ªß cho web game nh·∫π
            candidates.sort(() => Math.random() - 0.5); 
            candidates = candidates.slice(0, 25);
        }

        for (let idx of candidates) {
            gameState.board[idx] = aiPlayer;
            let score = minimax(gameState.board, depth, -Infinity, Infinity, false, aiPlayer);
            gameState.board[idx] = '';

            if (score > bestScore) {
                bestScore = score;
                move = idx;
            }
        }
        return move;
    }

    function minimax(simBoard, depth, alpha, beta, isMaximizing, aiPlayer) {
        const humanPlayer = aiPlayer === 'X' ? 'O' : 'X';
        
        const winAI = checkWin(simBoard, aiPlayer);
        if (winAI) return 100000 + depth; 
        
        const winHuman = checkWin(simBoard, humanPlayer);
        if (winHuman) return -100000 - depth; 

        if (depth === 0) return evaluateBoard(simBoard, aiPlayer);

        const candidates = getCandidateMoves(simBoard);
        if (candidates.length === 0) return 0; 

        // Limit branching factor inside recursion too
        let searchMoves = candidates;
        if (candidates.length > 12 && SETTINGS.size > 5) {
             searchMoves = candidates.slice(0, 12); 
        }

        if (isMaximizing) {
            let maxEval = -Infinity;
            for (let idx of searchMoves) {
                simBoard[idx] = aiPlayer;
                let ev = minimax(simBoard, depth - 1, alpha, beta, false, aiPlayer);
                simBoard[idx] = '';
                maxEval = Math.max(maxEval, ev);
                alpha = Math.max(alpha, ev);
                if (beta <= alpha) break;
            }
            return maxEval;
        } else {
            let minEval = Infinity;
            for (let idx of searchMoves) {
                simBoard[idx] = humanPlayer;
                let ev = minimax(simBoard, depth - 1, alpha, beta, true, aiPlayer);
                simBoard[idx] = '';
                minEval = Math.min(minEval, ev);
                beta = Math.min(beta, ev);
                if (beta <= alpha) break;
            }
            return minEval;
        }
    }

    function evaluateBoard(simBoard, player) {
        let score = 0;
        const size = SETTINGS.size;
        const winLen = SETTINGS.winLength;
        const directions = [{r:0, c:1}, {r:1, c:0}, {r:1, c:1}, {r:1, c:-1}];

        // Ch·ªâ qu√©t v√πng c√≥ qu√¢n ƒë·ªÉ t·ªëi ∆∞u
        // ·ªû ƒë√¢y qu√©t to√†n b·ªô ƒë∆°n gi·∫£n, nh∆∞ng v·ªõi 20x20 c√≥ th·ªÉ h∆°i ch·∫≠m.
        // Optimization: V√¨ ƒë·ªô s√¢u th·∫•p, h√†m n√†y g·ªçi nhi·ªÅu.
        
        for (let r = 0; r < size; r++) {
            for (let c = 0; c < size; c++) {
                const idx = r * size + c;
                if (simBoard[idx] === '') continue;
                
                const isMe = simBoard[idx] === player;
                const point = isMe ? 1 : -1.2; // TƒÉng bias ph√≤ng th·ªß

                for (let d of directions) {
                    // Check winLen sequence
                    // Ch·ªâ check n·∫øu ƒë·ªß ch·ªó
                    if (
                        r + d.r * (winLen-1) >= size || 
                        c + d.c * (winLen-1) >= size ||
                        r + d.r * (winLen-1) < 0 || 
                        c + d.c * (winLen-1) < 0
                    ) continue;

                    let count = 0;
                    let blocked = 0;
                    
                    // Check previous cell (blocker)
                    let pr = r - d.r, pc = c - d.c;
                    if (pr >=0 && pr < size && pc >=0 && pc < size && simBoard[pr*size+pc] !== '' && simBoard[pr*size+pc] !== simBoard[idx]) {
                        blocked++;
                    }

                    for(let k=0; k<winLen; k++) {
                        let nr = r + k*d.r;
                        let nc = c + k*d.c;
                        if (simBoard[nr*size+nc] === simBoard[idx]) count++;
                        else if (simBoard[nr*size+nc] !== '') {
                            // Blocked mid-way (should break loop logic differently but keeping simple heuristic)
                            count = 0; break; 
                        } else {
                            break; // Empty cell
                        }
                    }
                    
                    // Check next cell (blocker)
                    let nr = r + count*d.r, nc = c + count*d.c;
                    if (nr >=0 && nr < size && nc >=0 && nc < size && simBoard[nr*size+nc] !== '' && simBoard[nr*size+nc] !== simBoard[idx]) {
                        blocked++;
                    }

                    if (blocked === 2) continue; // B·ªã ch·∫∑n 2 ƒë·∫ßu -> v√¥ d·ª•ng

                    // Scoring
                    if (count === winLen) score += 10000 * point;
                    else if (count === winLen - 1) score += 500 * point;
                    else if (count === winLen - 2) score += 50 * point;
                }
            }
        }
        return score;
    }

    function getCandidateMoves(simBoard) {
        const size = SETTINGS.size;
        const candidates = new Set();
        const taken = [];
        
        for(let i=0; i<simBoard.length; i++) {
            if(simBoard[i] !== '') taken.push(i);
        }
        
        if(taken.length === 0) return [Math.floor((size*size)/2)];

        const dirs = [-1, 1, -size, size, -size-1, -size+1, size-1, size+1];

        for (let idx of taken) {
            let r = Math.floor(idx / size);
            let c = idx % size;
            for(let d of dirs) {
                let nIdx = idx + d;
                let nr = Math.floor(nIdx / size);
                let nc = nIdx % size;
                
                if(nIdx >= 0 && nIdx < size*size && Math.abs(nr - r) <= 1 && Math.abs(nc - c) <= 1) {
                    if(simBoard[nIdx] === '') candidates.add(nIdx);
                }
            }
        }
        return Array.from(candidates);
    }

    function checkWin(currentBoard, player) {
        const size = SETTINGS.size;
        const winLen = SETTINGS.winLength;
        const directions = [1, size, size+1, size-1];

        for (let i = 0; i < size * size; i++) {
            if (currentBoard[i] !== player) continue;

            let r = Math.floor(i / size);
            let c = i % size;

            for (let dir of directions) {
                let line = [i];
                let win = true;

                for (let k = 1; k < winLen; k++) {
                    let nextIdx = i + k * dir;
                    let nr = Math.floor(nextIdx / size);
                    let nc = nextIdx % size;

                    if (dir === 1 && nr !== r) win = false; 
                    else if (dir === size - 1 && Math.abs(nc - c) !== k) win = false; 
                    else if (dir === size + 1 && Math.abs(nc - c) !== k) win = false; 
                    
                    if (!win || nextIdx < 0 || nextIdx >= size*size || currentBoard[nextIdx] !== player) {
                        win = false;
                        break;
                    }
                    line.push(nextIdx);
                }

                if (win) return { winner: player, line: line };
            }
        }
        return null;
    }

    // Start show intro
    showIntro();

</script>
</body>
</html>
